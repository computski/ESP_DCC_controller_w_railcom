
#include "DCCEXprocessor.h"
#include "Global.h"
#include "DCCcore.h"


/*design notes
some outbound messages are generated in response to an incoming DCCEX command, but they may also be generated by
an incoming message on another channel or by user interation with the hardware interface

e.g. loco speed change could come from a non EX channel, and in which case it still needs to generate a broadcast message
to be added to the all-clients queue

*/




using namespace nsDCCEXprocessor;

static std::vector<CLIENTMESSAGE> messages;

enum parserState{
	SCAN,
	COMMAND,
	QUOTED_STRING
};

/// <summary>
/// Async client incoming message handler
/// </summary>
/// <param name="arg">pass through arguements from event</param>
/// <param name="client">TCP async client</param>
/// <param name="data">inbound data</param>
/// <param name="len">length of data</param>
void nsDCCEXprocessor::handleDCCEX(void* arg, AsyncClient* client, void* data, size_t len) {
	//need to replicate the newline token loop and call out to the processor

	//c.timeout here, if we are to do this
	
		
	trace(Serial.printf("\ndDCCEX client %s \n", client->remoteIP().toString().c_str());)

	//malloc gives more efficient memory usage than a fixed buffer
	char* buffer;
	buffer = (char*)malloc(len + 1);
	//incoming *data was void, need to cast to const char
	strncpy(buffer, (const char*)data, len);
	buffer[len] = '\0';  //terminate with a null


	//use state engine
	uint8_t parserStateEngine = SCAN;
	char* msg;//the command block enclosed within <markers>
	char* commandStartPtr; //pointer to most recently found command block
	uint8_t commandLen = 0; 
	
	for (uint8_t i = 0; i < len;i++) {
	
		switch (parserStateEngine) {
		case SCAN:
			if (buffer[i] == '<') {
				parserStateEngine = COMMAND;
				commandStartPtr = buffer + i;
				commandLen = 1;
			}
			break;
		case COMMAND:
			commandLen++;
			if (buffer[i] == '"') {
				parserStateEngine = QUOTED_STRING;
				break;
			}
			if (buffer[i] == '<') {
				parserStateEngine = SCAN;  //block error, restart scan
				commandStartPtr = buffer + i;
				commandLen = 1;
				break;
			}
			if (buffer[i] == '>') {
				//found a complete <command block> send to tokenprocessor
				msg = (char*)malloc(commandLen + 1);  
				strncpy(msg, commandStartPtr, commandLen); 
				msg[commandLen] = '\0'; 
				tokenProcessor(msg, client);
				free(msg);
				parserStateEngine = SCAN;
			}
			break;
		case QUOTED_STRING:
			commandLen++;
			//we do need to remap spaces because these are used as delimeters in the tokenProcessor
			if (buffer[i] == ' ') buffer[i] = '\xA0';  //escape a space
			//but we don't need to care about <> chars as these are inside the string
			//another " will exit the user string
			if (buffer[i] == '"') parserStateEngine = COMMAND;
			break;
		}
	}

	free(buffer);

	//https://www.w3schools.com/c/c_ref_string.php
	//can use memchr() to find next > char after we give it the pointer to the < we last worked with.

}




/// <summary>
/// build a message queue to be broadcast to all DCCEX clients
/// </summary>
/// <param name="clearQueue">clears all messages from queue</param>
void nsDCCEXprocessor::buildBroadcastQueue(bool clearQueue) {
	if (clearQueue) {
		messages.clear();
		return;
	}

	//build the queue

}

/// <summary>
/// process a single DCCEX token 
/// </summary>
/// <param name="msg">the token</param>
/// <param name="client">TCP client</param>
void nsDCCEXprocessor::tokenProcessor(char* msg, AsyncClient* client) {
	//break up the msg at space delimiters and feed into vector of strings
	//strtok will modify the original char* by adding nulls into it, so msg is modified
	//but there is no need to use free
	trace(Serial.printf("DCCEX %s \n", msg);)

		std::vector<std::string> tokens;
	char buf[25];

	char* tokenSplit = strtok(msg, " ");
	while (tokenSplit != NULL) {
		//remove any \xA0 escape chars for spaces in quoted strings
		for (int i = 0;i < strlen(tokenSplit);i++) {
			if (tokenSplit[i] == '\xA0') tokenSplit[i] = ' ';
		}
		tokens.push_back(tokenSplit);
		tokenSplit = strtok(NULL, " ");
	}

	//remove spurious spaces e.g. < # > generates 3 tokens and we need to reduce it to one
	//note that you must cast ->data() to std::string if you wish to do string compares
	for (auto it = tokens.begin(); it != tokens.end();it++) {
	
		if (it > tokens.begin()) {	
				if ("<"==(std::string)(it-1)->data()) {
					Serial.println("foo");
					//prior token is a solo <, append this token to it and then delete
					(it - 1)->append(it->data());
					it = tokens.erase(it);
				}
				if(">" == (std::string)it->data()) {
					//this token is a solo > so append > to prior token and delete this one
					(it - 1)->append(">");
					it = tokens.erase(it);
				}
		}
		//exit if the iterator is now pointing at last token as we cannot ++ past this.
		if (it == tokens.end()) break;
	}
	

	//DCCEX is a messy protocol. The <J... commands need concatenation
	//<J T> <JT> are equivalent as are <J T 44> <JT 44>, same for <JG> etc.
	//if we see <J then we must concatenate the second token into the first and delete the second
	if ((tokens[0] == "<J") && (tokens.size() > 1)) {
		tokens[0].append(tokens[1]);
		tokens.erase(tokens.begin() + 1);
	}


	//debug
	Serial.printf("tokens %d\n", tokens.size());
	//dump them
	for (int i = 0; i < tokens.size(); i++) {
		Serial.printf("%s %d\n", tokens[i].c_str(), atoi(tokens[i].c_str()));
	}
	Serial.println("______");
	//end debug


	//SIMPLE SINGLE TOKEN PROCESSING
	if (tokens.size() == 1) {
		if (tokens[0] == "<s>") {
			queueMessage("<iDCC - ESP / ESP8266 / No shield defined / 20251005>", client);
			//list all turnouts <H turnout_add 1|0> where 1 is thrown
			for (auto t : turnout) {
				sprintf(buf, "<H %d %d>\r\n", t.address, t.thrown ? 1 : 0);
				queueMessage(buf, client);
			}
			//send power status for good measure
			sprintf(buf, "<p%d>\r\n", power.trackPower ? 1 : 0);
			queueMessage(buf, client);
			return;

		}
		if (tokens[0] == "<1>") { nsDCCEXprocessor::setPower(true);return; }
		if (tokens[0] == "<0>") { nsDCCEXprocessor::setPower(false);return; }
		if (tokens[0] == "<=>") { queueMessage("<= A MAIN 0>\r\n", client);return; }//list power district

		if (tokens[0] == "<c>") {//<c "CurrentMAIN" current C "Milli" "0" max_ma "1" trip_ma>
			queueMessage("<c CurrentMAIN ", client);
			sprintf(buf, "%04d C ", power.bus_mA);  //only just enough space in buf
			queueMessage(buf, client);
			queueMessage("\"Milli\" \"0\" 4000 ", client);
			sprintf(buf, "\"1\" %04d>\r\n", bootController.currentLimit);
			queueMessage(buf, client);
			return;
		}

		if (tokens[0] == "<@>") { //virtual LCD
			queueMessage("<@ 0 0 \"DCC - ESP\">\r\n", client);
			sprintf(buf, "<@ 0 1 \"%d\">\r\n", bootController.softwareVersion);
			queueMessage(buf, client);
			return;
		}

		if (tokens[0] == "<JI>") { //current in the track, mA
			sprintf(buf, "<jI %04d>\r\n", power.bus_mA);
			queueMessage(buf, client);
			return;
		}

		if (tokens[0] == "<JG>") { //current trip threshold, mA
			sprintf(buf, "<jG %04d>\r\n", bootController.currentLimit);
			queueMessage(buf, client);
			return;
		}

		//unspported
		if (tokens[0] == "<Z>") { queueMessage("<X>\r\n", client); return; }  //list output pins
		if (tokens[0] == "<S>"){ queueMessage("<X>\r\n", client);return;}//list sensor pins
		if (tokens[0] == "<!>") { queueMessage("<X>\r\n", client);return; } //emergency stop
	}//end single token

	
	//TURNOUT PROCESSING
	if (tokens[0] == "<T>") { //list the turnouts and their states
		for (auto t : turnout) {
			sprintf(buf, "<H %d %d>\r\n", t.address, t.thrown ? 1 : 0);
			queueMessage(buf, client);
			return;
		}
	}

	if (tokens[0] == "<JT") {  //<JT id> request details of a specific turnout address
		uint16_t id = atoi(tokens[1].c_str());  //atoi will ignore trailing > 
		bool turnoutNotFound = true;
		for (auto t : turnout) {
			if (t.address == id) {
				//found the turnout, report its details <jT id X|state | "desc">
				sprintf(buf, "<jT %d %d \"%s\">\r\n", t.address, t.thrown ? 1 : 0, t.name);
				queueMessage(buf, client);
				turnoutNotFound = false;
				break;
			}
		}
		if (turnoutNotFound) {
			sprintf(buf, "<jT %d X>\r\n", id);
			queueMessage(buf, client);
		}
		return;
	}

	if (tokens[0] == "<T") {  //<T id state> turnout command but we need to find tokens within the msg
		//if turnout has not been seen before, it is added to the roster
		uint8_t turnoutSlot;

		if (tokens.size() != 3) return;

		//turnout id, but must be in range 1-2047
		uint16_t turnoutId = atoi(tokens[1].c_str());
		if (turnoutId > 2047) return;
		if (turnoutId == 0) return;
		turnoutSlot = findTurnout(turnoutId);

		switch ((tokens[2].c_str())[0])
		{
		case '1':
		case 'T':
			turnout[turnoutSlot].thrown = true;
			turnout[turnoutSlot].changeFlag = true;
			break;
		case '0':
		case 'C':
			turnout[turnoutSlot].thrown = false;
			turnout[turnoutSlot].changeFlag = true;
			break;
		default: //includes X for examine.
			//fake a change flag to trigger a broadcast of this turnout state
			turnout[turnoutSlot].changeFlag = true;
		}
		//the response will be a broadcast to all clients
		return;
	}

	//LOCOMOTIVE PROCESSING
	if (tokens[0] == "<R>") { //find loco address
		//This is non trivial. We have to read CV29 and then determine if we need to read reg 1 or reg 17+18
		//and so a state engine and timeout arrangement is required for this before a value can be returned
		//we also have to put the system into Service Mode
		queueMessage("<X>\r\n", client);
		return; } 

	if (tokens[0] == "<JR") {//<JR id> request details of specific loco entry
		if (tokens.size() == 2) {
			uint16_t locoAddressToQuery = atoi(tokens[1].c_str());
			if (locoAddressToQuery > 0) {
				for (auto l : loco) {
					if (l.address == locoAddressToQuery) {
						//resposnse <jR id "desc" "funct1/funct2/funct3/...">
						sprintf(buf, "<jR %d \"%s\" \"F0/F1/F2/F3/F4/F5/F6/F7/F8/F9/F10/F11/F12/F13/F14/F15\">\r\n", l.address, l.name);
						break;
					}
				}
			}
			else {
				//bad operation id zero or not found or non numeric
				sprintf(buf, "<jR %d \"\" \"\">\r\n", locoAddressToQuery);
				queueMessage(buf, client);
			}
		}
		return;
	}

	/*JRMI decoder pro throttles.   If you open two throttles on the same loco e.g. #3 from the same laptop, they will be synchronised
	for changes you make in the app, BUT they will not reflect any <t 1 2 3 4> responses you send back from the controller.  
	i.e. they are shit.   This is why ED is so much better.   Its not possible to have them sync to other control inputs made on other
	channels in the system such as the hardware unit, or ED.   For this reason, I am not inclined to support engine speed control.

	IF we do try to implement.  First, if we see an inbound command we need to add the loco to the roster if its not already in there.
	we then can set that speed as if this were a hardware interface, i.e. WiT will obey the speed, rather than us steal from WiT because 
	DCCEX does not support a steal concept.  If we set the speed as 10 on the JavaThrottle, then increase it to 50 on WiT, then the
	JavaThrottle becomes unsynchronised.  if the user moves it, then its commanded speed will override WiT.  i.e. you may see
	a speed jump.  You also have the issue that if the WiT executed a stop or eStop, the JavaThrottle will still be at the last commanded
	speed.

	The blurb says hitting "set" will ask the commandstation to release that loco so it  can be soley controlled by the JavaThrottle.
	That is incorrect re DCCEX.  no command is sent on "set". only <t..> commands once you move the throttle.

	Also if you hit a function button, DP will continously send the function command, approx 2 a second.  you cannot stop this, only
	close the throttle window.  Even releasing the loco does not stop the function commands.  i.e. its a bug.  don't use these throttles!

	*/



	if (tokens[0] == "<t") {  //<t cab speed dir> and also <t cab> and also <t junk cap speed dir>
		//these are speed commands to the cab, i.e. to a DCC address
		//do we add a loco to the roster if we have not seen it commanded before?  I think yes
		//but in my system, if all loco slots are in use and the locos moving, then no further locos can be commanded
		//we bump stationary locos.  To bump a moving loco means you lose control of it (except eStop).

		//ergh, nasty nasty protocol there is also <t junk cab speed dir> i.e. 4 params
		//in the 4 param ver speed=0-127 or -1 for estop, dir is 1|0 and cab is dcc address 1-10024 or whatever upper limit is
		//BUT there are complexities, because there's no concept of steal in DCCEX so all throttles just mirror each other for that given loco
		//and for my system, we have to assign a loco to a slot, we cannot just accept a random address.
		uint16_t locoAddress = 0;
		int8_t speed;  //0-127 or -1 for estop
		int8_t direction; //1 forward

		switch (tokens.size()) {
		case 2:
			//<t cab> this is a request for system to broadcast current status of the loco
			locoAddress = atoi(tokens[1].c_str());
			for (auto& l : loco) {
				if (l.address == locoAddress) {
					//spoof a change, this will cause the loco status to be broadcast
					l.changeFlag = true;
					break;
				}
			}
			return;

		case 4: //<t cab speed dir>
			locoAddress = atoi(tokens[1].c_str());
			speed = atoi(tokens[2].c_str());
			direction = atoi(tokens[3].c_str());
			break;
		case 5:
			locoAddress = atoi(tokens[1].c_str());
			speed = atoi(tokens[2].c_str());
			direction = atoi(tokens[3].c_str());
		}

		Serial.printf("lemon %d\n", locoAddress);


		if (locoAddress > 0){
			//valid parse, action the commanded speed+dir
			for (auto& l : loco) {
				if (l.address == locoAddress) {
					//is there a function to set speed?
					
					
					
					
					l.changeFlag = true;
					break;
				}
			}
			//return;


			//debug, just echo the command, I want to see if this causes the Java throttles to update
			//NO it does not.
			if (tokens.size() != 5) return;
		std::string s = tokens[0];
		s.append(" ");
		s.append(tokens[1]);
		s.append(" ");
		s.append(tokens[2]);
		s.append(" ");
		s.append(tokens[3]);
		s.append(" ");
		s.append(tokens[4]);
		queueMessage(s, client);
		return;
		}



	}


		
}//END FUNC





/// <summary>
/// DEPRECATED will process a single DCCEX token, i.e. <token here> 
/// </summary>
/// <param name="msg">the token</param>
/// <param name="client">TCP client</param>
void nsDCCEXprocessor::tokenProcessor(char* msg, AsyncClient* client,bool oldVersion) {
	trace(Serial.printf("DCCEX %s \n", msg);)
		char buf[20];


	//single char commands wrapped in < >
	char* p = strstr(msg, "<s>");
	if (p) {
		queueMessage("<iDCC - ESP / ESP32 / No shield at all G - devel - 202504182148Z>", client);
		//list all turnouts <H turnout_add 1|0> where 1 is thrown
		for (auto t : turnout) {
			sprintf(buf, "<H %d %d>\r\n", t.address, t.thrown ? 1 : 0);
			queueMessage(buf, client);
		}
		//send power status for good measure
		sprintf(buf, "<p%d>\r\n", power.trackPower ? 1 : 0);
		queueMessage(buf, client);
		return;
	}

	p = strstr(msg, "<1>");  //power on
	if (p) nsDCCEXprocessor::setPower(true);
	
	p = strstr(msg, "<0>");  //power off
	if (p) nsDCCEXprocessor::setPower(false);
		
	p = strstr(msg, "<Z>"); //list output pins
	if (p) 	queueMessage("<X>\r\n", client);
	
	p = strstr(msg, "<S>");  //list sensor pins
	if (p) queueMessage("<X>\r\n", client);
	
	p = strstr(msg, "<=>");  //list power district
	if (p) queueMessage("<= A MAIN 0>\r\n", client);
	
	p = strstr(msg, "<@>");  //virtual LCD
	if (p) {
		queueMessage("<@ 0 0 \"DCC - ESP\">\r\n", client);
		sprintf(buf, "<@ 0 1 \"%d\">\r\n", bootController.softwareVersion);
		queueMessage(buf, client);
		//queueMessage("<@ 0 1 \"2025-09-22\">\r\n", client);
	}

	p = strstr(msg, "<!>");  //emergency stop all locos
	if (p) {
		queueMessage("<X>\r\n", client);  //to implement
	}

	p = strstr(msg, "<JI>"); //current in the track, mA
	if (p) {
		sprintf(buf, "<jI %04d>\r\n", power.bus_mA);
		queueMessage(buf, client);
	}

	p = strstr(msg, "<JG>"); //current trip threshold, mA
	if (p) {
		sprintf(buf, "<jG %04d>\r\n", bootController.currentLimit);
		queueMessage(buf, client);
	}


	//SERVICE MODE RELATED
	p = strstr(msg, "<R>");  //read loco address, but how do we know if its short or long?
	//you'd first have to read cv 29 then either cv1 or cv17/18
	//and to read multiple values, you need a state engine because they are read asyncrhonously
	//far more complex than reading a single CV and responding back

	if (p) {
		queueMessage("<X>\r\n", client);
		return;	
	}



	p = strstr(msg, "<R ");  //read a CV
		if (p) {
		uint16_t cv_reg = atoi(msg + 3);  //atoi will ignore trailing > 
		if ((cv_reg <1) || (cv_reg > 1024)) {
			//bad cv
			queueMessage("<X>\r\n", client);
		}
		//we need to put the system into service mode and request a CV read. How do we know when to come out of service mode?
		//might need to cycle track power
		if (!power.serviceMode){
		writeServiceCommand(0, 0, false, true, false);
		//wait 200mS before a read can be initiated
		delayMicroseconds(2000);
		}

		writeServiceCommand(cv_reg, 0, true, false, false);
		//the result comes back asynchronously
		return;

	}





	//TURNOUT RELATED
	p = strstr(msg, "<T>"); //list the turnouts and their states
	if (p) {
		//list all turnouts <H turnout_add 1|0> where 1 is thrown
		for (auto t : turnout) {
			sprintf(buf, "<H %d %d>\r\n", t.address, t.thrown ? 1 : 0);
			queueMessage(buf, client);
		}
	}

	p = strstr(msg, "<JT ");  //<JT id> request details of a specific turnout address
	if (p) {
		//expect numeric followed by >
		uint16_t id = atoi(msg + 4);  //atoi will ignore trailing > 
		bool turnoutNotFound = true;
		for (auto t : turnout) {
			if (t.address == id) {
				//found the turnout, report its details <jT id X|state | "desc">
				sprintf(buf, "<jT %d %d \"%s\">\r\n", t.address, t.thrown ? 1 : 0, t.name);
				queueMessage(buf, client);
				turnoutNotFound = false;
				break;
			}
		}
		if (turnoutNotFound) {
			sprintf(buf, "<jT %d X>\r\n", id);
			queueMessage(buf, client);

		}
	}

	p = strstr(msg, "<T ");  //<T id state> turnout command but we need to find tokens within the msg
	//if turnout has not been seen before, it is added to the roster
	if (p) {
		char* tokenSplit = strtok(msg, " ");
		uint8_t tokenCount = 0;
		uint8_t turnoutSlot;
		while (tokenSplit != NULL)
		{
			if (tokenCount == 1) {
				//turnout id, but must be in range 1-2047
				uint16_t turnoutId = atoi(tokenSplit);
				if (turnoutId > 2047) break;
				if (turnoutId == 0) break;
				turnoutSlot = findTurnout(turnoutId);
			}
			if (tokenCount == 2) {
				switch (tokenSplit[0])
				{
				case '1':
				case 'T':
					turnout[turnoutSlot].thrown = true;
					turnout[turnoutSlot].changeFlag = true;
					break;
				case '0':
				case 'C':
					turnout[turnoutSlot].thrown = false;
					turnout[turnoutSlot].changeFlag = true;
					break;
				default: //includes X for examine.
					//fake a change flag to trigger a broadcast of this turnout state
					turnout[turnoutSlot].changeFlag = true;
				}

			}
			tokenCount++;
			tokenSplit = strtok(NULL, " ");
		}
		//if we broke out at token 1 because of a bad address, or we see fewer than 3 tokens 
		//we had a bad request
		if (tokenCount < 3) queueMessage("<X>\r\n", client);
	}


	//LOCOMOTIVE RELATED
	//DCC EX cannot support long addresses with values under 127, these are deemed to be short addresses
	//my own command station can support this, so its possible S32 and L32 both exist, but these DCC EX commands will just
	//operate on the first instance of 32 that they find.  Also <JR> will return <jR 32 32>
	p = strstr(msg, "<#>"); //how many loco slots are supported?
	if (p) {
		sprintf(buf, "<#%d>\r\n", MAX_LOCO);
		queueMessage(buf, client);
	}

	p = strstr(msg, "<JR>");  //also <J R> request loco roster
	//response <jR loco-addresses-separated-by-spaces>
	//don't need to concatenate addresses into a single string, instead we can emit each via queueMessage
	if (p) {
		queueMessage("<jR ", client);
		for (auto l : loco) {
			if (l.address != 0) {
				itoa(l.address, buf, 10);
				queueMessage(buf, client);
			}
		}
		queueMessage(">\r\n", client);
	}


	p = strstr(msg, "<JR ");  //<JR id> request details of specific loco entry
	if (p) {
		uint16_t locoAddressToQuery = atoi(msg + 4);
		if (locoAddressToQuery > 0) {
			for (auto l : loco) {
				if (l.address == locoAddressToQuery) {
					//resposnse <jR id "desc" "funct1/funct2/funct3/...">
					sprintf(buf, "<jR %d \"%s\" \"F0/F1/F2/F3/F4/F5/F6/F7/F8/F9/F10/F11/F12/F13/F14/F15\">\r\n", l.address, l.name);
					break;
				}
			}
		}
		else {
			//bad operation id zero or not found or non numeric
			sprintf(buf, "<jR %d \"\" \"\">\r\n", locoAddressToQuery);
			queueMessage(buf, client);
		}
	}

	p = strstr(msg, "<t ");  //<t cab speed dir> and also <t cab> and also <t junk cap speed dir>
	//these are speed commands to the cab, i.e. to a DCC address
	//do we add a loco to the roster if we have not seen it commanded before?  I think yes
	//but in my system, if all loco slots are in use and the locos moving, then no further locos can be commanded
	//we bump stationary locos.  To bump a moving loco means you lose control of it (except eStop).

	//ergh, nasty nasty protocol there is also <t junk cab speed dir> i.e. 4 params
	//in the 4 param ver speed=0-127 or -1 for estop, dir is 1|0 and cab is dcc address 1-10024 or whatever upper limit is
	//BUT there are complexities, because there's no concept of steal in DCCEX so all throttles just mirror each other for that given loco
	//and for my system, we have to assign a loco to a slot, we cannot just accept a random address.


	//NOTE: maybe its better to pull every <incoming> line of data into a vector of strings containing all tokens
	//and then parse through the vector.  this allows us to cope wth <J R xxx> as well as <JR xxx> and these daft multi optional
	//length commands like <t 1-to-4 params>  but we will split at space so last token may contain param> or > on its own.
	//e.g. <*> might appear as < * > as well


	
	if (p) {
		uint16_t locoAddress;
		int8_t speed;  //0-127 or -1 for estop
		int8_t direction; //1 forward

		
		
		bool parseSuccess = true;
		char* tokenSplit = strtok(msg, " ");
		char* args[4];  //received arguements, max 4. dynamically allocated
		uint8_t tokenCount = 0;
		while (tokenSplit != NULL){
			args[tokenCount] = (char*)malloc(strlen(tokenSplit) + 1);
			strcpy(args[tokenCount++], tokenSplit);
			tokenSplit = strtok(NULL, " ");
			if (tokenCount == 4)break;  //accept max 4 params
		}
		

		//do stuff with args...
		//<t cab> is just a status request
		switch(tokenCount) {
		case 2:

			break;
		case 5:
			tokenCount = 5;
		case 4:
			//process 2nd token onward
			tokenCount -= 3;

			//sprintf(buf, "%s %s %s\r\n", args[tokenCount], args[tokenCount+1], args[tokenCount+2]);
			Serial.printf("tt %s %s %s\n", args[tokenCount], args[tokenCount + 1], args[tokenCount + 2]);


			break;
		default:
			//zero or excessive tokens
			parseSuccess = false;
		}




	//free up dynamically allocated memory
	for (int i = 0; i < 3; i++) {
		free(args[i]);
	}

	if (!parseSuccess) queueMessage("<X>\r\n", client);  //bad


	}
}




/// <summary>
/// Transmit queued messages to a specific client. This will also transmit any broadcast messages
/// that have been queued up.  It will iterate the message queue.
/// </summary>
/// <param name="client">specific client to send to, cannot be nullptr</param>
void nsDCCEXprocessor::sendToClient(AsyncClient* client) {
	if (messages.empty()) return;
	if (client == nullptr) return;

	std::string outBoundMessage;
	outBoundMessage.clear();

	//build the outBoundMessage from client specific messages plus any broadcast messages
	for (auto m : messages) {
		if ((m.toClient == nullptr) || (m.toClient == client)) {
			outBoundMessage.append(m.msg);
		}
	}

	//find specific client messages or nullptr broadast, and send
	//const char *data = s.c_str(); will cause a crash if you use it to call client->add
	//need to copy the data to a new array

	if (outBoundMessage.size() > 0) {
		char* data = new char[outBoundMessage.size() + 1];
		copy(outBoundMessage.begin(), outBoundMessage.end(), data);
		data[outBoundMessage.size()] = '\0';

		//send over TCP/IP
		if (client->space() > sizeof(data) && client->canSend()) {
			client->add(data, strlen(data));
			client->send();
		}

		//we used new to create *data.  delete now else you create a memory leak
		delete data;
	}
}

/// <summary>
/// callback from DCCcore when a SM value is read from track
/// </summary>
/// <param name="cvReg">register</param>
/// <param name="cvVal">readback value, negative if fail</param>
void nsDCCEXprocessor::broadcastSMreadResult(uint16_t cvReg, int16_t cvVal) {
	char buf[20];
	if (cvVal > 0) {
		sprintf(buf, "<v %d %d>\r\n", cvReg, cvVal);
	}
	else {
		sprintf(buf, "<v %d -1>\r\n", cvReg);
	}
	queueMessage(buf, nullptr);
}



#pragma region internal_functions


/// <summary>
/// queue a message for a specific client, or all
/// </summary>
/// <param name="s">standard string containing message</param>
/// <param name="client">spcific client, or all if nullptr</param>
 void nsDCCEXprocessor::queueMessage(std::string s, AsyncClient* client) {
	CLIENTMESSAGE m;
	m.toClient = client;
	m.msg = s;
	messages.push_back(m);
}


 void nsDCCEXprocessor::setPower(bool powerOn) {
	//any power on/off state change will zero loco speeds
	for (auto& loc : loco) {
		loc.speed = 0;
		loc.speedStep = 0;
		loc.changeFlag = true;
	}

	//queue a broadcast message
	if (powerOn) {
		queueMessage("<p1>\r\n", nullptr);
	}
	else {
		queueMessage("<p0>\r\n", nullptr);
	}
	power.trackPower = powerOn;
	power.trip = false;


}

#pragma endregion
