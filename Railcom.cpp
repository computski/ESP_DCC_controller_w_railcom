// 
// 
// 
#include "Global.h"
#include "Railcom.h"
//dependencies
#include "DCCweb.h"
#include "DCClayer1.h"

/*debug notes
* we see bytes if JP1 is in place.  if JP1 is removed, the bytes stop.
* Its probable that noise will exist during the RC cutout that serial will interpret as data
* There is no way to flush/reset the receive buffer in Arduino other than to read all data.   There are supposedly datagrams in the railcom protocol
* so we should be able to extract valid data from what might appear to be an async stream of random stuff.
*
* 
* DCCpacket.railcomCutoutActive is a flag generated by DCClayer1, it is true during the railcom cutout and so allows the main routine to 'gate' the serial data
* against the loco who's packet we are processing.  We need to be aware of when we update DCCpacket with new data vs when we read the serial port.
* 
* 
* Rules
* we can read/write to an address that may not even be in the roster.  for this reason we don't index LOCO 
* if reading from a non roster loco, the only way we will see rc data from that loco is to keep sending it POM read packets for 0.5sec, because the regular loco packets won't 
* every transmit to the target loco address
* we timeout after 80 packets, this is approx 0.5s
* 
*/




using namespace nsRailcom;

const uint8_t decode[] = {
0b10101100,0b10101010,0b10101001,0b10100101,0b10100011,0b10100110,0b10011100,0b10011010,0b10011001,0b10010101,0b10010011,0b10010110,0b10001110,0b10001101,0b10001011,0b10110001,
0b10110010,0b10110100,0b10111000,0b01110100,0b01110010,0b01101100,0b01101010,0b01101001,0b01100101,0b01100011,0b01100110,0b01011100,0b01011010,0b01011001,0b01010101,0b01010011,
0b01010110,0b01001110,0b01001101,0b01001011,0b01000111,0b01110001,0b11101000,0b11100100,0b11100010,0b11010001,0b11001001,0b11000101,0b11011000,0b11010100,0b11010010,0b11001010,
0b11000110,0b11001100,0b01111000,0b00010111,0b00011011,0b00011101,0b00011110,0b00101110,0b00110110,0b00111010,0b00100111,0b00101011,0b00101101,0b00110101,0b00111001,0b00110011,
0b00001111,0b11110000,0b11100001};
#define RC_NACK 0x40
#define RC_ACK 0x41
#define RC_BUSY 0x42

struct RC_MSG {
	uint8_t state;
	uint16_t locoAddr;
	bool    useLongAddr;
	uint8_t datagram[6];
	uint8_t datagramIndex;
	uint8_t value;
	bool	isValid;
	uint8_t validBytesDebug;
}rc_msg;

enum RC_STATE
{
	RC_START,   //equivalent to expect ID=0
	RC_APPEND,
	RC_SUCCESS,
	RC_FAIL,
	RC_TIMEOUT,
	RC_IDLE
};



/// <summary>
/// Initialise UART for railcom, start listening for incoming data
/// </summary>
void nsRailcom::railcomInit() {
	Serial.println(F("\n\nEnable railcom"));
	Serial.flush();

	readRailcom(0,false);

	Serial.end();
	//railcom uses 250kbaud
	Serial.begin(250000);




}

/// <summary>
/// Call once per program loop
/// </summary>
void nsRailcom::railcomLoop(void) {
	static uint8_t byteNew;
	static uint8_t byteOld;
	uint8_t j;

	//check for serial.available and if so decode it and send it over the websocket

	/*
		JsonDocument out;
		out["type"] = "railcom";
		out["payload"] = "test";
		nsDCCweb::sendJson(out);
	*/

#if IGNORE
	if (Serial.available() > 0) {
		// read the incoming byte:
		byteNew = Serial.read();

		if ((byteOld == 0xAC) && (byteNew == 0x95)) {
			//saw 0xAC95 sequence

			JsonDocument out;
			out["type"] = "railcom";
			out["payload"] =  "0xAC95";
			nsDCCweb::sendJson(out);

		}
		byteOld = byteNew;




		// say what you got:
		//Serial.print("I received: ");
		//Serial.println(incomingByte, DEC);
	}
#endif

	//test 1: read serial but discard if we are not in a current rcCutout
	//test 2: only read data that is relevant to target loco.  How?  the rc data occurs during a cutout which is at the end of a packet and there's a good
	//change the packet will already have been reloaded into the double buffer, meaning that the one actively being transmitted is in the low level buffer in layer1
	//the lazy way to get around this is stay in POM packet mode for 0.5s

	while (Serial.available() > 0) {
		// read the incoming byte:
		byteNew = Serial.read();
		//only examine if we are expecting new datagrams
	
		do {
			//use a one-pass do-while, as this allows us to break from the logic and avoid nested ifs. more elegant than a goto :-)

			if (!(rc_msg.state == RC_START || rc_msg.state == RC_APPEND)) break;
			
			
			//if (!DCCpacket.doCutout) break;
					//gate-in data during the cutout
					//ah but we might actually be processing serial outside of this window.... hmmm
					//also should an 80 packet timeout erase the prior cv read and reset the state engine?  probably no as we want to know the prior result

					//expect railcom POM response to read, which is ID=0 and 2 byte datagram
					//and we will only gate-in valid data

					//we need to be aware that we are looking for 2 bytes and then process them
					//lets just receive 2 and then work out if we see ID=POM etc.


					if (decodeRailcom(byteNew, &rc_msg.datagram[rc_msg.datagramIndex++])) {

						//safety valve, if datagramIndex has incremented too far
						if (rc_msg.datagramIndex >= 5) 
						{
							rc_msg.datagramIndex = 5;
							rc_msg.state = RC_FAIL;
							break;
						}

						rc_msg.validBytesDebug++;

						if (rc_msg.datagramIndex == 1) {
							//check we have ID=0  aka POM
							if ((rc_msg.datagram[0] & 0b00111100) != 0) {
								//no, so reset, leave in start state
								rc_msg.datagramIndex = 0;
								break;
							}
						}

						//saw valid ID=0, and can proceed with pulling in data
						rc_msg.state = RC_APPEND;
						if (rc_msg.datagramIndex == 2) {
								rc_msg.value = rc_msg.datagram[0] << 6;
								rc_msg.value += (rc_msg.datagram[1] & 0b00111111);   
								rc_msg.state = RC_SUCCESS;
								rc_msg.isValid = true;

								//we would then consume this, but need to indicate we have e.g. with RC_DONE

								JsonDocument out;
								out["type"] = "railcom";
								out["payload"] = rc_msg.value;
								out["success"] = "y";
								out["count"] = rc_msg.validBytesDebug;

								nsDCCweb::sendJson(out);
						}

					}
					else {
						//data not a 4/8 byte.  re-start, but remember we have a packet timeout still running
						rc_msg.state = RC_START;
						rc_msg.datagramIndex = 0;
					}
			
		} while (false);



	}//serial avail loop

	//have we timedout?
	//on the start and append status we might timeout

	if (DCCpacket.railcomPacketCount == 0) {
		switch (rc_msg.state) {
		case RC_SUCCESS:
		case RC_FAIL:
		case RC_IDLE:
			break;
		default:
			rc_msg.state = RC_TIMEOUT;

			//bugger, we only want to send this message once


			JsonDocument out;
			out["type"] = "railcom";
			out["payload"] = "timeout";
			out["count"] = rc_msg.validBytesDebug;
			nsDCCweb::sendJson(out);
			rc_msg.state = RC_IDLE;
		}
	}


}

/*we need a railcomPacketEngine
resets on bad data
buffers incoming valid bytes
is aware of ACK/ NACK
is aware of which loco we are reading
and holds last valid read from this
is also reset from external trigger, i.e. when read is initiated

don't intend to use it to read loco ids from ch1

*/

/// <summary>
/// Reset railcom reader, and look for incoming data for locoIndex
/// </summary>
/// <param name="locoIndex"></param>
void nsRailcom::readRailcom(uint16_t addr, bool useLongAddr) {
	rc_msg.locoAddr = addr;
	rc_msg.useLongAddr = useLongAddr;
	rc_msg.state = RC_START;
	memset(rc_msg.datagram, '\0', sizeof(rc_msg.datagram));
	rc_msg.datagramIndex = 0;
	rc_msg.isValid = false;
	rc_msg.validBytesDebug = 0;
	DCCpacket.railcomPacketCount = 80;
	
	JsonDocument out;
	out["type"] = "railcom";
	out["payload"] = "start";
	out["loco"] = rc_msg.locoAddr;
	nsDCCweb::sendJson(out);
}


		bool nsRailcom::decodeRailcom(uint8_t inByte, uint8_t * dataOut) {
			for (int i = 0; i <=RC_BUSY; i++) {   
				if (inByte == decode[i]) {
					//valid
					*dataOut = i;
					return true;
				}
			}
			//didn't find a match
			*dataOut = 0;
			return false;
		}





