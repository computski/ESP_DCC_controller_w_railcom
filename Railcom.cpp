#include "Global.h"
#include "Railcom.h"
#include "DCCweb.h"
#include "DCClayer1.h"

/*debug notes
* we see bytes if JP1 is in place.  if JP1 is removed, the bytes stop.
* Its probable that noise will exist during the RC cutout that serial will interpret as data
* There is no way to flush/reset the receive buffer in Arduino other than to read all data.   There are supposedly datagrams in the railcom protocol
* so we should be able to extract valid data from what might appear to be an async stream of random stuff.
*
*
* DCCpacket.railcomCutoutActive is a flag generated by DCClayer1, it is true during the railcom cutout and so allows the main routine to 'gate' the serial data
* against the loco who's packet we are processing.  We need to be aware of when we update DCCpacket with new data vs when we read the serial port.
*
*
* Rules
* we can read/write to an address that may not even be in the roster.  for this reason we don't index LOCO
* if reading from a non roster loco, the only way we will see rc data from that loco is to keep sending it POM read packets for 0.5sec, because the regular loco packets won't
* every transmit to the target loco address
* we timeout after 80 packets, this is approx 0.5s
*
* 
* 2024-11-14 serious bug.  you read a cv and railcom gives you the result for the prior cv read.  why?
* start shows the correct input values, and actual request to m_POM sets up correct cvReg but then seems to read back a prior value as if this were buffered somewhere
* which it is not.  the websock sniffer shows the wrong value being returned.  This is presumably what's on the rails so the decoder is responding with a prior value???
* 
* 
* 
*/

using namespace nsRailcom;




/// <summary>
/// Initialise UART for railcom, start listening for incoming data
/// </summary>
void nsRailcom::railcomInit() {
	Serial.println(F("\n\nEnable railcom"));
	Serial.flush();

	readRailcom(0, false,1);

	Serial.end();
	//railcom uses 250kbaud
	Serial.begin(250000);
}


/// <summary>
/// Call once per program loop
/// </summary>
void nsRailcom::railcomLoop(void) {

	while (Serial.available() > 0) {
		// read the incoming byte:
		uint8_t byteNew = Serial.read();
		//only examine if we are expecting new datagrams

		switch (rc_msg.state) {
		case RC_EXPECT_ID0:
			if (decodeRailcom(byteNew, &rc_msg.data_ID0)) {
				//was this a valid ID0?
				if ((rc_msg.data_ID0 & 0b00111100) == 0) {
					//valid
					rc_msg.state = RC_EXPECT_B1;
				}
			}
			break;

		case RC_EXPECT_B1:
			if (decodeRailcom(byteNew, &rc_msg.data_1)) {
				//we now have a result
				rc_msg.data_ID0 = rc_msg.data_ID0 << 6;
				rc_msg.data_1 += rc_msg.data_ID0;
				rc_msg.state = RC_SUCCESS;
				JsonDocument out;
				out["type"] = "dccUI";
				out["cmd"] = "pom";
				out["action"] = "byteQ";
				char buff[7];
				itoa(rc_msg.data_1, buff, 10);
				out["cvVal"] = buff;  //yes you can assign char[] to a json param
				out["pkt"] = DCCpacket.railcomPacketCount;
				nsDCCweb::sendJson(out);
			}
			else
			{
				//bad data, revert to expect ID0
				rc_msg.state = RC_EXPECT_ID0;
			}
			break;
		}

	}//serial avail loop

	//have we timedout?
	//on the start and append status we might timeout

	if (DCCpacket.railcomPacketCount == 0) {
		switch (rc_msg.state) {
		case RC_SUCCESS:
		case RC_FAIL:
		case RC_IDLE:
			break;
		default:
			rc_msg.state = RC_TIMEOUT;
			//send message just once. a failed read will present as ???

			JsonDocument out;
			out["type"] = "dccUI";
			out["cmd"] = "pom";
			out["action"] = "byteQ";
			out["cvVal"] = "???";  //yes you can assign char[] to a json param
			nsDCCweb::sendJson(out);
			rc_msg.state = RC_IDLE;
		}
	}


}


/// <summary>
/// Expect a railcom response from a specific loco address
/// </summary>
/// <param name="addr">loco address</param>
/// <param name="useLongAddr">is a long address</param>
void nsRailcom::readRailcom(uint16_t addr, bool useLongAddr, uint16_t cvReg) {
	rc_msg.locoAddr = addr;
	rc_msg.useLongAddr = useLongAddr;
	rc_msg.state = RC_EXPECT_ID0;
	DCCpacket.railcomPacketCount = 80;

	JsonDocument out;
	out["type"] = "railcom";
	out["payload"] = "start";
	out["loco"] = rc_msg.locoAddr;
	out["cv"] = cvReg;
	nsDCCweb::sendJson(out);
}

/// <summary>
/// decode an incoming railcom databyte
/// </summary>
/// <param name="inByte">incoming data</param>
/// <param name="dataOut">decoded value</param>
/// <returns>true if incoming was a 4/8 coded byte</returns>
bool nsRailcom::decodeRailcom(uint8_t inByte, uint8_t* dataOut) {
	for (int i = 0; i <= RC_BUSY; i++) {
		if (inByte == decode[i]) {
			//valid
			*dataOut = i;
			return true;
		}
	}
	//didn't find a match
	*dataOut = 0;
	return false;
}










