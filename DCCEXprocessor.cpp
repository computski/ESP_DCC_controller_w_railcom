
#include "DCCEXprocessor.h"
#include "Global.h"
#include "DCCcore.h"


/*design notes
some outbound messages are generated in response to an incoming DCCEX command, but they may also be generated by
an incoming message on another channel or by user interation with the hardware interface

e.g. loco speed change could come from a non EX channel, and in which case it still needs to generate a broadcast message
to be added to the all-clients queue

*/




using namespace nsDCCEXprocessor;

static std::vector<CLIENTMESSAGE> messages;

enum parserState{
	SCAN,
	COMMAND,
	QUOTED_STRING
};

/// <summary>
/// Async client incoming message handler
/// </summary>
/// <param name="arg">pass through arguements from event</param>
/// <param name="client">TCP async client</param>
/// <param name="data">inbound data</param>
/// <param name="len">length of data</param>
void nsDCCEXprocessor::handleDCCEX(void* arg, AsyncClient* client, void* data, size_t len) {
	//need to replicate the newline token loop and call out to the processor

	//c.timeout here, if we are to do this
	
		
	trace(Serial.printf("\ndDCCEX client %s \n", client->remoteIP().toString().c_str());)

	//malloc gives more efficient memory usage than a fixed buffer
	char* buffer;
	buffer = (char*)malloc(len + 1);
	//incoming *data was void, need to cast to const char
	strncpy(buffer, (const char*)data, len);
	buffer[len] = '\0';  //terminate with a null


	//use state engine
	uint8_t parserStateEngine = SCAN;
	char* msg;//the command block enclosed within <markers>
	char* commandStartPtr; //pointer to most recently found command block
	uint8_t commandLen = 0; 
	
	for (uint8_t i = 0; i < len;i++) {
	
		switch (parserStateEngine) {
		case SCAN:
			if (buffer[i] == '<') {
				parserStateEngine = COMMAND;
				commandStartPtr = buffer + i;
				commandLen = 1;
			}
			break;
		case COMMAND:
			commandLen++;
			if (buffer[i] == '"') {
				parserStateEngine = QUOTED_STRING;
				break;
			}
			if (buffer[i] == '<') {
				parserStateEngine = SCAN;  //block error, restart scan
				commandStartPtr = buffer + i;
				commandLen = 1;
				break;
			}
			if (buffer[i] == '>') {
				//found a complete <command block> send to tokenprocessor
				msg = (char*)malloc(commandLen + 1);  
				strncpy(msg, commandStartPtr, commandLen); 
				msg[commandLen] = '\0'; 
				tokenProcessor(msg, client);
				free(msg);
				parserStateEngine = SCAN;
			}
			break;
		case QUOTED_STRING:
			commandLen++;
			//we do need to remap spaces because these are used as delimeters in the tokenProcessor
			if (buffer[i] == ' ') buffer[i] = '\xA0';  //escape a space
			//but we don't need to care about <> chars as these are inside the string
			//another " will exit the user string
			if (buffer[i] == '"') parserStateEngine = COMMAND;
			break;
		}
	}

	free(buffer);

	//https://www.w3schools.com/c/c_ref_string.php
	//can use memchr() to find next > char after we give it the pointer to the < we last worked with.

}




/// <summary>
/// build a message queue to be broadcast to all DCCEX clients
/// </summary>
/// <param name="clearQueue">clears all messages from queue</param>
void nsDCCEXprocessor::buildBroadcastQueue(bool clearQueue) {
	if (clearQueue) {
		messages.clear();
		return;
	}

	//build the queue.   We will build a detail dump of all turnouts and all locos if their rosterflag is set
	//will also send out the power status

	


}

/// <summary>
/// process a single DCCEX token 
/// </summary>
/// <param name="msg">the token</param>
/// <param name="client">TCP client</param>
void nsDCCEXprocessor::tokenProcessor(char* msg, AsyncClient* client) {
	//break up the msg at space delimiters and feed into vector of strings
	//strtok will modify the original char* by adding nulls into it, so msg is modified
	//but there is no need to use free
	trace(Serial.printf("DCCEX %s \n", msg);)

	std::vector<std::string> tokens;
	#define BUFSIZE 25
	char buf[BUFSIZE];

	char* tokenSplit = strtok(msg, " ");
	while (tokenSplit != NULL) {
		//remove any \xA0 escape chars for spaces in quoted strings
		for (int i = 0;i < strlen(tokenSplit);i++) {
			if (tokenSplit[i] == '\xA0') tokenSplit[i] = ' ';
		}
		tokens.push_back(tokenSplit);
		tokenSplit = strtok(NULL, " ");
	}

	//remove spurious spaces e.g. < # > generates 3 tokens and we need to reduce it to one
	//note that you must cast ->data() to std::string if you wish to do string compares
	for (auto it = tokens.begin(); it != tokens.end();it++) {
	
		if (it > tokens.begin()) {	
				if ("<"==(std::string)(it-1)->data()) {
					//prior token is a solo <, append this token to it and then delete
					(it - 1)->append(it->data());
					it = tokens.erase(it);
				}
				if(">" == (std::string)it->data()) {
					//this token is a solo > so append > to prior token and delete this one
					(it - 1)->append(">");
					it = tokens.erase(it);
				}
		}
		//exit if the iterator is now pointing at last token as we cannot ++ past this.
		if (it == tokens.end()) break;
	}
	

	//DCCEX is a messy protocol. smh. The <J... commands need concatenation
	//<J T> <JT> are equivalent as are <J T 44> <JT 44>, same for <JG> etc. 
	//if we see <J then we must concatenate the second token into the first and delete the second
	//NET OF ALL OF THIS we will have single token commands where there are no params.
	if ((tokens[0] == "<J") && (tokens.size() > 1)) {
		tokens[0].append(tokens[1]);
		tokens.erase(tokens.begin() + 1);
	}


	//debug
	trace (
	Serial.printf("tokens %d\n", tokens.size());
	//dump them
	for (int i = 0; i < tokens.size(); i++) {
		Serial.printf("%s\n", tokens[i].c_str());
	}
	Serial.println("______");
		)
	//end debug


	//SIMPLE SINGLE TOKEN PROCESSING
	if (tokens.size() == 1) {
		if (tokens[0] == "<s>") {
			queueMessage("<iDCC - ESP / ESP8266 / No shield defined / 20251005>", client);
			//list all turnouts <H turnout_add 1|0> where 1 is thrown
			//DCCex indexes turnouts by a numeric handle, not the dcc address and not the slot and not a text name.
			//my equivalence is to use .name as the ID but only if it is numeric
			for (auto t : turnout) {
				if (t.address == 0) continue;
				uint16_t nameAsNumeric = atoi(t.name);
				if (nameAsNumeric == 0) continue;  //skip any roster entries with text names
				snprintf(buf,BUFSIZE, "<H %d %d>\r\n", nameAsNumeric, t.thrown ? 1 : 0);
				queueMessage(buf, client);
			}
			//send power status for good measure
			snprintf(buf, BUFSIZE,"<p%d>\r\n", power.trackPower ? 1 : 0);
			queueMessage(buf, client);
			return;

		}

		if (tokens[0] == "<1>") { nsDCCEXprocessor::setPower(true);return; }
		if (tokens[0] == "<0>") { nsDCCEXprocessor::setPower(false);return; }
		if (tokens[0] == "<=>") { queueMessage("<= A MAIN 0>\r\n", client);return; }//list power district

		if (tokens[0] == "<c>") {//<c "CurrentMAIN" current C "Milli" "0" max_ma "1" trip_ma>
			queueMessage("<c CurrentMAIN ", client);
			snprintf(buf, BUFSIZE,"%04d C ", power.bus_mA);  //only just enough space in buf
			queueMessage(buf, client);
			queueMessage("\"Milli\" \"0\" 4000 ", client);
			snprintf(buf, BUFSIZE, "\"1\" %04d>\r\n", bootController.currentLimit);
			queueMessage(buf, client);
			return;
		}

		if (tokens[0] == "<@>") { //virtual LCD
			queueMessage("<@ 0 0 \"DCC - ESP\">\r\n", client);
			snprintf(buf, BUFSIZE, "<@ 0 1 \"%d\">\r\n", bootController.softwareVersion);
			queueMessage(buf, client);
			queueMessage("<@ 0 2 \"RAILCOM\">\r\n", client);
			return;
		}

		if (tokens[0] == "<JI>") { //current in the track, mA
			snprintf(buf, BUFSIZE,"<jI %04d>\r\n", power.bus_mA);
			queueMessage(buf, client);
			return;
		}

		if (tokens[0] == "<JG>") { //current trip threshold, mA
			snprintf(buf, BUFSIZE,"<jG %04d>\r\n", bootController.currentLimit);
			queueMessage(buf, client);
			return;
		}

		if (tokens[0] == "<!>") {//emergency stop, signal this in a broadcast
			for (auto& loc : loco) {
				loc.speed = 0;
				loc.speedStep = 0;
				//note a non-zero eStopTimer lets the dcc packet engine know to transmit an estop message
				loc.eStopTimer = LOCO_ESTOP_TIMEOUT;
				//flag a change so this gets broadcast over all channels
				loc.changeFlag = true;
			}
			return;
		}

		//unspported
		if (tokens[0] == "<Z>") { queueMessage("<X>\r\n", client); return; }  //list output pins
		if (tokens[0] == "<S>"){ queueMessage("<X>\r\n", client);return;}//list sensor pins
	
	}//end single token

	
	//TURNOUT PROCESSING
	//DCCex does not support text names for turnouts, instead it has a numeric id handle which is a name of sorts as well as the DCC address
	//my system supports a text name and an address.   What this means, is that DCCex can add/delete/command numeric "names" but it won't be able to
	//add/delete/command any existing turnouts in the roster if they have non numeric names. 
	

	

	if (tokens[0] == "<T>") { //list the turnouts and their states over multiple rows <H id state>
		//will only do this for turnouts with numeric .name
		bool foundNoTurnouts = true;
	
		for (auto t : turnout) {
			trace(Serial.printf("T %s\r\n", t.name);)
			uint16_t nameAsNumeric = atoi(t.name);
			if (nameAsNumeric == 0) continue;
			if (t.address == 0) continue;
			snprintf(buf, BUFSIZE, "<H %d %d>\r\n", nameAsNumeric, t.thrown ? 1 : 0);
			queueMessage(buf, client);
			foundNoTurnouts = false;
		}
		if (foundNoTurnouts) {
			queueMessage("<X>\r\n", client);
		}
		return;
	}
	
	if (tokens[0] == "<T") {  
		//<T id state> command a turnout to move
		//<T id> delete a turnout from rostr
		//<T id DCC linear> adds a turnout
		//<T id DCC add subAddr> adds a turnout
		//<T id addr subAddr> adds a turnout, deprecated but Decoder Pro uses it. smh.
		//DCCex requires a turnout to be added to the roster before any position commands can be sent to it
				
				
		//turnout id, DCCex upper limit is int16
		uint16_t turnoutId = atoi(tokens[1].c_str()); 
		if (turnoutId == 0) return;
		//Beware that in 2-token messages tokens[1] contains a trailling >
		//so restate the token
		itoa(turnoutId, buf, 10);
		tokens[1] = buf;
				

		TURNOUT* ptrTurnout = nullptr;
		//iterate the actual turnout array, not a copy of it :-)
		for (auto &t : turnout) {
			if (t.address == 0) continue;
			if (tokens[1] == t.name) {
				ptrTurnout = &t;
				break;
			}
		}

		if (tokens.size() == 2) { //<T id> remove id from roster
			if (ptrTurnout == nullptr) {
				//no match on numeric id
				queueMessage("<X>\r\n", client);
				return;
			}
			//clear turnout slot if we found it
			ptrTurnout->address = 0;
			memset(ptrTurnout->name, '\0', sizeof(ptrTurnout->name));
			ptrTurnout->selected = false;
			bootController.flagTurnoutRoster = true;
			queueMessage("<0>\r\n", client);
			return;
		}

		//three versions of command to add a turnout
		//<T id DCC linear> 
		//<T id DCC add subAddr> 
		//<T id addr subAddr> 
	if ((tokens.size() == 4) || (tokens.size() == 5)) {
		//convert all addresses to linear form

		uint16_t turnoutAddress = 0;
		
		if (tokens[2] == "DCC") {
			if (tokens.size() == 4) {
				//<T id DCC linear> 
				turnoutAddress = atoi(tokens[3].c_str());
			}
			else {
				//<T id DCC add subAddr> 
				turnoutAddress =4 * atoi(tokens[3].c_str());
				turnoutAddress+= atoi(tokens[4].c_str());
			}

		}
		else
		{//<T id addr subAddr> 
			turnoutAddress = 4 * atoi(tokens[2].c_str());
			turnoutAddress += atoi(tokens[3].c_str());
		}

		//we don't validate the addr-sub limits, we just test the final turnout address for range
		if (turnoutAddress > 2047) return;
		if (turnoutAddress == 0) return;

		if (ptrTurnout == nullptr) {
			uint16_t turnoutSlot = findTurnout(turnoutAddress); //Find index slot of a given turnout address, or assign a new one
			snprintf(turnout[turnoutSlot].name, sizeof(turnout[turnoutSlot].name), "%d", turnoutId);
			trace(Serial.printf("T add %d\r\n", turnoutAddress);)

		}
		else {
			//just update dcc address
			ptrTurnout->address = turnoutAddress;
			trace(Serial.printf("T update %d\r\n", turnoutAddress);)

		}
		return;

		}//end add-turnout block



	/*
		if (tokens.size() == 4) {
		//add a turnout <T id addr subaddr>
		//if the id already exists, there is no need to recreate but we should overwrite the DCC address
			
			uint16_t turnoutAddress = atoi(tokens[2].c_str());
			uint8_t subAddress = atoi(tokens[3].c_str());
			if (turnoutAddress > 511) return;
			if (subAddress > 3) return;
			//recalculate as a linear address.
			turnoutAddress *= 4;
			turnoutAddress += subAddress;
			turnoutAddress += subAddress;
			if (turnoutAddress == 0) return;

			if (ptrTurnout == nullptr) {
				uint16_t turnoutSlot = findTurnout(turnoutAddress); //Find index slot of a given turnout address, or assign a new one
				snprintf(turnout[turnoutSlot].name, 8, "%d", turnoutId);
				trace(Serial.printf("T add %d\r\n", turnoutAddress);)

			}
			else {
				//just update dcc address
				ptrTurnout->address = turnoutAddress;
				trace(Serial.printf("T update %d\r\n", turnoutAddress);)

			}
			return;

		}
		*/


		//else, this is a position command
		//trace(Serial.printf("T slot %d %s\r\n", turnoutSlot,tokens[2].c_str());)  //debug
		if (ptrTurnout == nullptr) return;


		//dealing with a turnout position command
		switch ((tokens[2].c_str())[0])
		{
		case '1':
		case 'T':
			ptrTurnout->thrown = true;
			ptrTurnout->changeFlag = true;
			break;
		case '0':
		case 'C':
			ptrTurnout->thrown = false;
			ptrTurnout->changeFlag = true;
			break;
		default: //includes X for examine.
			//The DCC specifies X will return <H id DCC address subaddress state> 
			//whereas <T> or <s> will emit <H id linearAddress>
			//what a nasty messy protocol. smh.  Also X is the only way to find out what DCC address is assigned to a turnout.
			uint16_t addr = atoi(ptrTurnout->name);
			uint8_t subAddr = addr % 4;
			addr = addr >> 2;
			
			snprintf(buf, BUFSIZE,"<H %s DCC %d %d %d>\r\n", ptrTurnout->name, addr, subAddr , ptrTurnout->thrown ? 1 : 0);
			queueMessage(buf, client);

		}
		//the response will be a broadcast to all clients.
		//if findTurnout() added to the roster, it will flag the roster for broadcast
		trace(Serial.println("T pos");)
		return;
	}

	if (tokens[0] == "<JT>") {//list the turnout roster in a single row. <jT 1 2 ...> 
		//Why have this and <T>? smh.
		//note, I will emit only numeric 'names' from the roster
		std::string s;
		s.append("<jT");
		for (auto t : turnout) {
			//only emit turnouts with numeric names
			uint16_t nameAsNumeric = atoi(t.name);
			if (nameAsNumeric == 0) continue;
			if (t.address == 0) continue;
			s.append(" ");
			s.append(t.name);
		}
		s.append(">\r\n");
		queueMessage(s, client);
		return;
	}

	if (tokens[0] == "<JT") {  
		//<JT id> request details of a specific turnout address
		//DCCex does not support giving text names to turnouts, but it can return any existing text descriptor. smh.
		//not that id does not have any stated bounds so lets support uint_16 as a 'name' aka id

		if (tokens.size() < 2) {
			//malformed request
			queueMessage("<X>\r\n", client);
			return;
		}

		uint16_t turnoutId = atoi(tokens[1].c_str());
		if (turnoutId == 0)  {
			//malformed request, we effectively use atoi to check if id is numeric
			queueMessage("<X>\r\n", client);
			return;
		}

		//In 2 token messages token[1] has a trailing > so rewrite it as numeric
		itoa(turnoutId, buf, 10);
		tokens[1] = buf;

			//we need to find by its name in the roster but only if numeric, because DCCex supports only numeric "id"
			//DCCex does support retrieving a text descriptor, but does not allow you to set one. smh.
			//This means all turnouts defined from DCCex will have t.name matching their id.
			
				for (auto t : turnout) {
					if (tokens[1] != t.name) continue;
					//found the turnout, report its details <jT id X|state | "desc">
					snprintf(buf, BUFSIZE, "<jT %s %d \"%s\">\r\n", t.name, t.thrown ? 1 : 0, t.name);
					queueMessage(buf, client);
					return;
				}
				//turnoutId zero or not found in roster
				snprintf(buf, BUFSIZE,"<jT %d X>\r\n", turnoutId);
				queueMessage(buf, client);
				return;
	
	}


	//LOCOMOTIVE PROCESSING
	//https://www.jmri.org/help/en/html/apps/DecoderPro/Roster.shtml
	//it appears JMRI does not try to maintain a roster on the controller and DCCex has no commands to add a loco to the roster
	//it can read the loco roster with <JR> but cannot delete from it or add to it.
	//In a regular JMRI system, the laptop is the server, ED can see the roster and pick up a loco from it and ED will then issue commands
	//to the JMRI server (speed, dir etc) and the server is expected to on-instruct the controller - or at least that's why I assume.

	//so we may have reached a dead end.  there's no way for JMRI to interrogate the loco roster on my controller, nor write to it.
	//If you start WiThrottle server on the laptop, ED can connect to it and select a loco from the roster.  At that point, the throttle will
	//issue commands which JMRI will map to <t 1 3 126 0> type commands (i.e. the 5 token deprecated type).  first digit is meaningless
	//second is dcc address, then speed step and finally dir

	//these throttle messages are seen by JMRI but are not sent out to the controller... so again, no way for it to see and respond
	//to the ED translated-to-DCCex messages.



	if (tokens[0] == "<R>") { //find loco address
		//This is non trivial. We have to read CV29 and then determine if we need to read reg 1 or reg 17+18
		//and so a state engine and timeout arrangement is required for this before a value can be returned
		//we also have to put the system into Service Mode
		//I will not implement this because I don't think JMRI invokes it.

		//debug, spoof a response.  DP does not seem to do anything with this information.
		queueMessage("<r 72>\r\n", client);
		return; } 

	if (tokens[0] == "<JR>") { //request loco roster
		//<jR [id1 id2 ...]>  note the protocol is inconsistent with <T> turnout listing per line. smh.
		//there is always at least 1 loco in the roster (default loco 3)
		std::string s;
		s.append("<jR");

		for (auto l : loco) {
			if (l.address == 0) continue;
			sprintf(buf, " %d", l.address);
			s.append(buf);
			
		}
		s.append(">\r\n");
		queueMessage(s, client);
		return;
	}


	if (tokens[0] == "<JR") {//<JR id> request details of specific loco entry
		
		if (tokens.size() == 2) {
			uint16_t locoAddressToQuery = atoi(tokens[1].c_str());
			if (locoAddressToQuery > 0) {
				for (auto l : loco) {
					if (l.address == locoAddressToQuery) {
						std::string s;
						//response <jR id "desc" "funct1/funct2/funct3/...">
						//buf has limited chars, so append to std string
						snprintf(buf, BUFSIZE,"<jR %d \"%s\"", l.address, l.name);
						s.append(buf);
						s.append(" \"F0/F1/F2/F3/F4/F5/F6/F7/F8/F9/F10/F11/F12/F13/F14/F15\">\r\n");
						queueMessage(s, client);
						return;
					}
				}
				//were given a numeric but its not in roster. Bad protocol design, as it might be a valid loco with no name and no functions. 
				//nevertheless this is considered not-in-roster smh.
				snprintf(buf, BUFSIZE,"<jR %d \"\" \"\">\r\n", locoAddressToQuery);
				queueMessage(buf, client);
				return;
			}
		}

		//malformed request
		queueMessage("<X>\r\n", client);
		return;
	}


	/*JMRI Decoder Pro throttles.  If you open two throttles on the same loco on the same laptop they will be synchronised 
	for changes in the app, BUT they will not reflect any <t 1 2 3 4> responses from the controller.  i.e. they are a poor 
	implmentation compared to Engine Driver.  DP also seems to keep sending function commands endlessly if you invoke one.
	
	DCCex protocol does not support a steal concept for throttles.

	Given that DP and DCCex do a poor job of synchrnoising throttles across the system given we may have inputs from ED or the Hardware,
	I will not implment any DCCex throttle commands.  My advice; use Engine Driver.
	
	The <- cab> command is ignored.  My system will continuously transmit locos in the roster.  You need to remove from roster to kill the DCC output.
	*/


	if (tokens[0] == "<t") {  //<t cab speed dir> and also <t cab> and also <t junk cap speed dir>
		//not implmented, use Engine Driver for throttles.
		queueMessage("<X>\r\n", client);
		return;
	}

	if (tokens[0] == "<F") { //<F cab funct state>
		//not implmented, use Engine Driver for throttles.
		queueMessage("<X>\r\n", client);
		return;
	}

	if (tokens[0] == "<f") {//deprecated
		queueMessage("<X>\r\n", client);
		return;
	}



		
}//END FUNC



/// <summary>
/// Transmit queued messages to a specific client. This will also transmit any broadcast messages
/// that have been queued up.  It will iterate the message queue.
/// </summary>
/// <param name="client">specific client to send to, cannot be nullptr</param>
void nsDCCEXprocessor::sendToClient(AsyncClient* client) {
	if (messages.empty()) return;
	if (client == nullptr) return;

	std::string outBoundMessage;
	outBoundMessage.clear();

	//build the outBoundMessage from client specific messages plus any broadcast messages
	for (auto m : messages) {
		if ((m.toClient == nullptr) || (m.toClient == client)) {
			outBoundMessage.append(m.msg);
		}
	}

	//find specific client messages or nullptr broadast, and send
	//const char *data = s.c_str(); will cause a crash if you use it to call client->add
	//need to copy the data to a new array

	if (outBoundMessage.size() > 0) {
		char* data = new char[outBoundMessage.size() + 1];
		copy(outBoundMessage.begin(), outBoundMessage.end(), data);
		data[outBoundMessage.size()] = '\0';

		//send over TCP/IP
		if (client->space() > sizeof(data) && client->canSend()) {
			client->add(data, strlen(data));
			client->send();
		}

		//we used new to create *data.  delete now else you create a memory leak
		delete data;
	}
}

/// <summary>
/// callback from DCCcore when a SM value is read from track
/// </summary>
/// <param name="cvReg">register</param>
/// <param name="cvVal">readback value, negative if fail</param>
void nsDCCEXprocessor::broadcastSMreadResult(uint16_t cvReg, int16_t cvVal) {
	char buf[20];
	if (cvVal > 0) {
		sprintf(buf, "<v %d %d>\r\n", cvReg, cvVal);
	}
	else {
		sprintf(buf, "<v %d -1>\r\n", cvReg);
	}
	queueMessage(buf, nullptr);
}



#pragma region internal_functions


/// <summary>
/// queue a message for a specific client, or all
/// </summary>
/// <param name="s">standard string containing message</param>
/// <param name="client">spcific client, or all if nullptr</param>
 void nsDCCEXprocessor::queueMessage(std::string s, AsyncClient* client) {
	CLIENTMESSAGE m;
	m.toClient = client;
	m.msg = s;
	messages.push_back(m);
}


 void nsDCCEXprocessor::setPower(bool powerOn) {
	//any power on/off state change will zero loco speeds
	for (auto& loc : loco) {
		loc.speed = 0;
		loc.speedStep = 0;
		loc.changeFlag = true;
	}

	//queue a broadcast message
	if (powerOn) {
		queueMessage("<p1>\r\n", nullptr);
	}
	else {
		queueMessage("<p0>\r\n", nullptr);
	}
	power.trackPower = powerOn;
	power.trip = false;


}

#pragma endregion
